<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>„Ç§„É≥„Éâ„Ç¢„Ç≥„Éº„Éï„Éú„Éº„É´Êà¶Áï•„Éú„Éº„ÉâÔºàÂçäÈù¢Ôºâ- ÂãïÁîªÊ©üËÉΩ‰ªò„Åç</title>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #f0f2f5;
            overflow-x: hidden;
        }

        .app-container {
            display: flex;
            flex-direction: column;
            height: 100vh;
        }

        /* Header */
        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 15px 20px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        .header h1 {
            font-size: 24px;
            font-weight: 600;
        }

        /* Toolbar */
        .toolbar {
            background: white;
            padding: 15px 20px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            align-items: center;
        }

        .tool-group {
            display: flex;
            gap: 5px;
            align-items: center;
            padding: 0 10px;
            border-right: 1px solid #ddd;
        }

        .tool-group:last-child {
            border-right: none;
        }

        .btn {
            padding: 8px 16px;
            border: none;
            border-radius: 6px;
            background: #f0f2f5;
            color: #333;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .btn:hover {
            background: #e4e6eb;
            transform: translateY(-1px);
        }

        .btn.active {
            background: #667eea;
            color: white;
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .btn-primary {
            background: #667eea;
            color: white;
        }

        .btn-primary:hover {
            background: #5568d3;
        }

        .btn-success {
            background: #10b981;
            color: white;
        }

        .btn-success:hover {
            background: #059669;
        }

        .btn-warning {
            background: #f59e0b;
            color: white;
        }

        .btn-warning:hover {
            background: #d97706;
        }

        .btn-danger {
            background: #ef4444;
            color: white;
        }

        .btn-danger:hover {
            background: #dc2626;
        }

        /* Main Content */
        .main-content {
            flex: 1;
            display: flex;
            overflow: hidden;
        }

        /* Canvas Area */
        .canvas-area {
            flex: 1;
            display: flex;
            flex-direction: column;
            background: #e5e7eb;
            padding: 20px;
            overflow: auto;
        }

        .canvas-wrapper {
            background: white;
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            padding: 20px;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 500px;
        }

        canvas {
            max-width: 100%;
            max-height: 100%;
            cursor: default;
        }

        /* Frame Controls */
        .frame-controls {
            background: white;
            padding: 15px 20px;
            box-shadow: 0 -2px 5px rgba(0,0,0,0.1);
            display: flex;
            gap: 10px;
            align-items: center;
            flex-wrap: wrap;
        }

        .frame-info {
            font-weight: 600;
            color: #667eea;
            padding: 8px 12px;
            background: #f0f2f5;
            border-radius: 6px;
        }

        .frame-list {
            display: flex;
            gap: 5px;
            flex-wrap: wrap;
            flex: 1;
        }

        .frame-btn {
            padding: 8px 12px;
            border: 2px solid #d1d5db;
            border-radius: 6px;
            background: white;
            cursor: pointer;
            font-size: 13px;
            transition: all 0.2s;
        }

        .frame-btn:hover {
            border-color: #667eea;
        }

        .frame-btn.active {
            background: #667eea;
            color: white;
            border-color: #667eea;
        }

        /* Playback Controls */
        .playback-controls {
            display: flex;
            gap: 10px;
            align-items: center;
            padding: 0 10px;
            border-left: 2px solid #ddd;
        }

        .speed-control {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .speed-control label {
            font-size: 12px;
            color: #666;
        }

        .speed-control input[type="range"] {
            width: 100px;
        }

        /* Color Picker */
        .color-picker {
            display: flex;
            gap: 5px;
            flex-wrap: wrap;
        }

        .color-option {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            cursor: pointer;
            border: 2px solid transparent;
            transition: all 0.2s;
        }

        .color-option:hover {
            transform: scale(1.1);
        }

        .color-option.active {
            border-color: #333;
            box-shadow: 0 0 0 2px white, 0 0 0 4px #333;
        }

        /* Input Groups */
        .input-group {
            margin-bottom: 15px;
        }

        .input-group label {
            display: block;
            font-size: 13px;
            margin-bottom: 5px;
            color: #6b7280;
        }

        .input-group input,
        .input-group select {
            width: 100%;
            padding: 8px;
            border: 1px solid #d1d5db;
            border-radius: 6px;
            font-size: 14px;
        }

        /* Modal */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.5);
            z-index: 1000;
            align-items: center;
            justify-content: center;
        }

        .modal.active {
            display: flex;
        }

        .modal-content {
            background: white;
            border-radius: 12px;
            padding: 30px;
            max-width: 500px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
        }

        .modal-header {
            font-size: 20px;
            font-weight: 600;
            margin-bottom: 20px;
        }

        .modal-actions {
            display: flex;
            gap: 10px;
            margin-top: 20px;
            justify-content: flex-end;
        }

        textarea {
            width: 100%;
            padding: 10px;
            border: 1px solid #d1d5db;
            border-radius: 6px;
            font-family: monospace;
            font-size: 12px;
            min-height: 200px;
        }

        /* Responsive */
        @media (max-width: 768px) {
            .toolbar {
                overflow-x: auto;
            }
            
            .frame-controls {
                overflow-x: auto;
            }
        }
    </style>
</head>
<body>
    <div class="app-container">
        <!-- Header -->
        <div class="header">
            <h1>‚öΩ „Ç§„É≥„Éâ„Ç¢„Ç≥„Éº„Éï„Éú„Éº„É´Êà¶Áï•„Éú„Éº„ÉâÔºàÂçäÈù¢Ôºâ- ÂãïÁîªÊ©üËÉΩ‰ªò„Åç</h1>
        </div>

        <!-- Toolbar -->
        <div class="toolbar">
            <div class="tool-group">
                <button class="btn active" data-tool="select" title="ÈÅ∏Êäû„ÉªÁßªÂãï">
                    üñ±Ô∏è ÈÅ∏Êäû
                </button>
                <button class="btn" data-tool="freehand" title="„Éï„É™„Éº„Éè„É≥„ÉâÊèèÁîª">
                    ‚úèÔ∏è ÊèèÁîª
                </button>
                <button class="btn" data-tool="eraser" title="Ê∂à„Åó„Ç¥„É†">
                    üßπ Ê∂àÂéª
                </button>
            </div>

            <div class="tool-group">
                <label style="font-size: 12px; color: #666;">Á∑ö„ÅÆÂ§™„Åï:</label>
                <input type="range" id="lineWidth" min="1" max="8" value="3" style="width: 80px;">
                <span id="lineWidthValue" style="font-size: 12px; color: #666;">3</span>
            </div>

            <div class="tool-group">
                <div class="color-picker">
                    <div class="color-option active" data-color="#000000" style="background: #000000;" title="Èªí"></div>
                    <div class="color-option" data-color="#ef4444" style="background: #ef4444;" title="Ëµ§"></div>
                    <div class="color-option" data-color="#3b82f6" style="background: #3b82f6;" title="Èùí"></div>
                </div>
            </div>

            <div class="tool-group">
                <button class="btn" id="undoBtn" title="ÂÖÉ„Å´Êàª„Åô">‚Ü©Ô∏è</button>
                <button class="btn" id="redoBtn" title="„ÇÑ„ÇäÁõ¥„Åó">‚Ü™Ô∏è</button>
                <button class="btn" id="clearDrawingBtn" title="ÊèèÁîª„Çí„ÇØ„É™„Ç¢">üóëÔ∏è ÊèèÁîª</button>
                <button class="btn btn-danger" id="resetBtn" title="ÂÖ®„Å¶„É™„Çª„ÉÉ„Éà">üîÑ „É™„Çª„ÉÉ„Éà</button>
            </div>

            <div class="tool-group">
                <button class="btn btn-primary" id="saveBtn">üíæ ‰øùÂ≠ò</button>
                <button class="btn btn-primary" id="loadBtn">üìÇ Ë™≠Ëæº</button>
                <button class="btn btn-primary" id="exportBtn">üì∏ PNGÂá∫Âäõ</button>
            </div>
        </div>

        <!-- Main Content -->
        <div class="main-content">
            <!-- Canvas Area -->
            <div class="canvas-area">
                <div class="canvas-wrapper">
                    <canvas id="indoorKorfballBoard"></canvas>
                </div>
            </div>
        </div>

        <!-- Frame Controls -->
        <div class="frame-controls">
            <div class="frame-info">
                <span>„Éï„É¨„Éº„É†: <span id="currentFrameDisplay">1</span> / <span id="totalFramesDisplay">1</span></span>
            </div>
            
            <div class="tool-group">
                <button class="btn btn-success" id="addFrameBtn">‚ûï „Éï„É¨„Éº„É†ËøΩÂä†</button>
                <button class="btn btn-warning" id="duplicateFrameBtn">üìã Ë§áË£Ω</button>
                <button class="btn btn-danger" id="deleteFrameBtn">üóëÔ∏è ÂâäÈô§</button>
            </div>

            <div class="frame-list" id="frameList"></div>

            <div class="playback-controls">
                <button class="btn btn-success" id="playBtn">‚ñ∂Ô∏è ÂÜçÁîü</button>
                <button class="btn btn-warning" id="stopBtn" style="display: none;">‚è∏Ô∏è ÂÅúÊ≠¢</button>
                <label>
                    <input type="checkbox" id="loopCheckbox" checked>
                    <span style="font-size: 12px;">„É´„Éº„Éó</span>
                </label>
                <div class="speed-control">
                    <label>ÈÄüÂ∫¶:</label>
                    <input type="range" id="playbackSpeed" min="100" max="3000" value="1000" step="100">
                    <span id="speedValue" style="font-size: 12px; color: #666;">1.0x</span>
                </div>
            </div>
        </div>
    </div>

    <!-- Save Modal -->
    <div class="modal" id="saveModal">
        <div class="modal-content">
            <div class="modal-header">„Éó„É¨„Ç§„Çí‰øùÂ≠ò</div>
            <div class="input-group">
                <label>„Éó„É¨„Ç§Âêç</label>
                <input type="text" id="playName" placeholder="‰æã: „Ç™„Éï„Çß„É≥„Çπ1">
            </div>
            <div class="input-group">
                <label>„Éá„Éº„ÇøÔºàËá™ÂãïÁîüÊàêÔºâ</label>
                <textarea id="saveData" readonly></textarea>
            </div>
            <div class="modal-actions">
                <button class="btn" id="closeSaveModal">„Ç≠„É£„É≥„Çª„É´</button>
                <button class="btn btn-primary" id="copyDataBtn">„Ç≥„Éî„Éº</button>
            </div>
        </div>
    </div>

    <!-- Load Modal -->
    <div class="modal" id="loadModal">
        <div class="modal-content">
            <div class="modal-header">„Éó„É¨„Ç§„ÇíË™≠„ÅøËæº„Åø</div>
            <div class="input-group">
                <label>„Éá„Éº„Çø„ÇíË≤º„Çä‰ªò„Åë</label>
                <textarea id="loadData" placeholder="‰øùÂ≠ò„Åó„ÅüJSON„Éá„Éº„Çø„ÇíË≤º„Çä‰ªò„Åë„Å¶„Åè„Å†„Åï„ÅÑ"></textarea>
            </div>
            <div class="modal-actions">
                <button class="btn" id="closeLoadModal">„Ç≠„É£„É≥„Çª„É´</button>
                <button class="btn btn-primary" id="loadDataBtn">Ë™≠„ÅøËæº„Åø</button>
            </div>
        </div>
    </div>

    <script>
        // Constants for Indoor Korfball (Half Court)
        const COURT_WIDTH = 20; // meters
        const COURT_LENGTH = 20; // meters (square court)
        const BORDER_WIDTH = 2; // meters
        const PLAYER_RADIUS = 0.7; // meters - increased for better visibility
        const KORF_X = 10; // meters - center of court width
        const KORF_Y = 6.7; // meters - from back of court
        const FREE_PASS_CENTER_OFFSET = 2.5; // meters - distance from korf to center of free pass circle
        const FREE_PASS_RADIUS = 2.5; // meters - radius of free pass circle
        const PENALTY_RADIUS = 2.5; // meters - radius of penalty arc
        const PENALTY_WIDTH = 7.5; // meters - width at back of court

        // Canvas setup
        const canvas = document.getElementById('indoorKorfballBoard');
        const ctx = canvas.getContext('2d');
        let scale;

        // Set initial canvas size to prevent blank screen
        canvas.width = 800;
        canvas.height = 800;

        // State
        let currentTool = 'select';
        let currentColor = '#000000';
        let currentLineWidth = 3;
        let frames = [];
        let currentFrameIndex = 0;
        let selectedObject = null;
        let isDragging = false;
        let offset = { x: 0, y: 0 };
        let drawingStart = null;
        let tempDrawing = null;
        let history = [];
        let historyIndex = -1;
        
        // Playback state
        let isPlaying = false;
        let playbackInterval = null;
        let playbackSpeed = 1000; // milliseconds per frame
        let loopPlayback = true;

        // Initialize first frame
        function createNewFrame() {
            const courtStartX = BORDER_WIDTH;
            const courtStartY = BORDER_WIDTH;
            const courtWidth = COURT_WIDTH;
            const courtLength = COURT_LENGTH;

            return {
                players: [
                    // Team A (Red) - Upper area: 2 circles (1, 2)
                    {position: [courtStartX + courtWidth * 0.25, courtStartY + courtLength * 0.35], color: '#ef4444', number: '1', gender: 'boy', team: 'A'},
                    {position: [courtStartX + courtWidth * 0.5, courtStartY + courtLength * 0.22], color: '#ef4444', number: '2', gender: 'boy', team: 'A'},
                    // Team A (Red) - Lower area: 2 triangles (3, 4) - left side bottom
                    {position: [courtStartX + courtWidth * 0.12, courtStartY + courtLength * 0.75], color: '#ef4444', number: '3', gender: 'girl', team: 'A'},
                    {position: [courtStartX + courtWidth * 0.18, courtStartY + courtLength * 0.90], color: '#ef4444', number: '4', gender: 'girl', team: 'A'},
                    // Team B (Blue) - Upper/Center: 2 circles (5, 6)
                    {position: [courtStartX + KORF_X + 1.2, courtStartY + KORF_Y + 0.5], color: '#3b82f6', number: '5', gender: 'boy', team: 'B'},
                    {position: [courtStartX + courtWidth * 0.75, courtStartY + courtLength * 0.35], color: '#3b82f6', number: '6', gender: 'boy', team: 'B'},
                    // Team B (Blue) - Lower area: 2 triangles (7, 8) - center bottom
                    {position: [courtStartX + courtWidth * 0.42, courtStartY + courtLength * 0.80], color: '#3b82f6', number: '7', gender: 'girl', team: 'B'},
                    {position: [courtStartX + courtWidth * 0.58, courtStartY + courtLength * 0.80], color: '#3b82f6', number: '8', gender: 'girl', team: 'B'},
                ],
                ball: { position: [courtStartX + courtWidth * 0.25 + 1.5, courtStartY + courtLength * 0.35], color: '#FFEB3B', radius: 0.45 },
                korf: { position: [courtStartX + KORF_X, courtStartY + KORF_Y] },
                drawings: []
            };
        }

        frames.push(createNewFrame());

        // Resize canvas
        function resizeCanvas() {
            const totalWidth = COURT_WIDTH + 2 * BORDER_WIDTH;
            const totalHeight = COURT_LENGTH + 2 * BORDER_WIDTH;
            const aspectRatio = totalWidth / totalHeight;

            const maxWidth = window.innerWidth - 40;
            const maxHeight = window.innerHeight - 250; // Adjusted for frame controls

            if (maxWidth / maxHeight > aspectRatio) {
                canvas.height = maxHeight;
                canvas.width = canvas.height * aspectRatio;
            } else {
                canvas.width = maxWidth;
                canvas.height = canvas.width / aspectRatio;
            }

            scale = canvas.width / totalWidth;
            draw();
        }

        // Drawing functions
        function drawCourt() {
            const courtStartX = BORDER_WIDTH * scale;
            const courtStartY = BORDER_WIDTH * scale;
            const courtWidthPx = COURT_WIDTH * scale;
            const courtLengthPx = COURT_LENGTH * scale;

            // Background gradient for border area
            const bgGradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            bgGradient.addColorStop(0, '#e8f5e8');
            bgGradient.addColorStop(1, '#d4ead4');
            ctx.fillStyle = bgGradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Shadow for court
            ctx.shadowColor = 'rgba(0, 0, 0, 0.2)';
            ctx.shadowBlur = 15;
            ctx.shadowOffsetX = 0;
            ctx.shadowOffsetY = 5;

            // Main court - green field effect
            const greenGradient = ctx.createLinearGradient(
                courtStartX, 
                courtStartY, 
                courtStartX, 
                courtStartY + courtLengthPx
            );
            greenGradient.addColorStop(0, '#7CCD7C');
            greenGradient.addColorStop(0.5, '#6FBF6F');
            greenGradient.addColorStop(1, '#62B162');
            ctx.fillStyle = greenGradient;
            ctx.fillRect(courtStartX, courtStartY, courtWidthPx, courtLengthPx);

            ctx.shadowColor = 'transparent';
            ctx.shadowBlur = 0;
            ctx.shadowOffsetX = 0;
            ctx.shadowOffsetY = 0;

            // Outer boundary - black line
            ctx.strokeStyle = '#000000';
            ctx.lineWidth = 4;
            ctx.strokeRect(courtStartX, courtStartY, courtWidthPx, courtLengthPx);

            // Center line (horizontal) - at bottom of this half-court zone
            ctx.strokeStyle = '#000000';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(courtStartX, courtStartY + courtLengthPx);
            ctx.lineTo(courtStartX + courtWidthPx, courtStartY + courtLengthPx);
            ctx.stroke();

            // Calculate key positions
            const korfXMeters = BORDER_WIDTH + KORF_X;
            const korfYMeters = BORDER_WIDTH + KORF_Y;
            
            // Penalty spot is 2.5m in front of (forward from) the korf
            const penaltySpotX = korfXMeters;
            const penaltySpotY = korfYMeters + 2.5;
            
            const korfXPx = korfXMeters * scale;
            const korfYPx = korfYMeters * scale;
            const penaltySpotXPx = penaltySpotX * scale;
            const penaltySpotYPx = penaltySpotY * scale;
            const radius = 2.5 * scale;

            // Penalty spot marker line (15cm √ó 5cm line in front of korf)
            ctx.strokeStyle = '#000000';
            ctx.lineWidth = 2;
            ctx.fillStyle = '#000000';
            ctx.fillRect(penaltySpotXPx - 0.075 * scale, penaltySpotYPx - 0.025 * scale, 0.15 * scale, 0.05 * scale);

            // Free pass area - complete circle around penalty spot
            ctx.strokeStyle = '#000000';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(penaltySpotXPx, penaltySpotYPx, radius, 0, 2 * Math.PI);
            ctx.stroke();

            // Penalty area - full stadium/capsule shape
            ctx.strokeStyle = '#000000';
            ctx.lineWidth = 2.5;
            ctx.beginPath();
            
            // Start from bottom-left
            ctx.moveTo(penaltySpotXPx - radius, korfYPx);
            
            // Left vertical line
            ctx.lineTo(penaltySpotXPx - radius, penaltySpotYPx);
            
            // Top semicircle (around penalty spot)
            ctx.arc(penaltySpotXPx, penaltySpotYPx, radius, Math.PI, 0, false);
            
            // Right vertical line
            ctx.lineTo(penaltySpotXPx + radius, korfYPx);
            
            // Bottom semicircle (around korf) - arc pointing upward
            ctx.arc(korfXPx, korfYPx, radius, 0, Math.PI, true);
            
            ctx.closePath();
            ctx.stroke();
        }

        function drawKorfAtPosition() {
            const frame = frames[currentFrameIndex];
            if (frame.korf) {
                const x = frame.korf.position[0] * scale;
                const y = frame.korf.position[1] * scale;
                drawKorf(x, y);
            }
        }

        function drawKorf(x, y) {
            // Dark yellow circle for korf (goal) - larger size
            ctx.beginPath();
            ctx.arc(x, y, 0.45 * scale, 0, 2 * Math.PI);
            ctx.fillStyle = '#D4A017'; // Dark yellow/golden
            ctx.fill();
            ctx.strokeStyle = '#000000';
            ctx.lineWidth = 2;
            ctx.stroke();
        }

        function drawPlayer(player) {
            const {position, color, number, gender} = player;
            const x = position[0] * scale;
            const y = position[1] * scale;
            const playerSize = PLAYER_RADIUS * scale;

            ctx.fillStyle = color;
            ctx.strokeStyle = 'black';
            ctx.lineWidth = 2;

            if (gender === 'boy') {
                // Male players: circle
                ctx.beginPath();
                ctx.arc(x, y, playerSize, 0, 2 * Math.PI);
                ctx.fill();
                ctx.stroke();
            } else {
                // Female players: square
                ctx.fillRect(x - playerSize, y - playerSize, playerSize * 2, playerSize * 2);
                ctx.strokeRect(x - playerSize, y - playerSize, playerSize * 2, playerSize * 2);
            }

            ctx.fillStyle = 'white';
            ctx.font = `bold ${playerSize * 1.0}px Arial`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(number, x, y);
        }

        function drawBall() {
            const frame = frames[currentFrameIndex];
            const x = frame.ball.position[0] * scale;
            const y = frame.ball.position[1] * scale;
            const radius = frame.ball.radius * scale;

            ctx.beginPath();
            ctx.arc(x, y, radius, 0, 2 * Math.PI);
            ctx.fillStyle = frame.ball.color;
            ctx.fill();
            ctx.strokeStyle = 'black';
            ctx.lineWidth = 2;
            ctx.stroke();
        }

        function drawArrow(from, to, color, lineWidth = 3) {
            const headLength = 15;
            const angle = Math.atan2(to.y - from.y, to.x - from.x);

            ctx.strokeStyle = color;
            ctx.fillStyle = color;
            ctx.lineWidth = lineWidth;
            ctx.lineCap = 'round';

            // Line
            ctx.beginPath();
            ctx.moveTo(from.x, from.y);
            ctx.lineTo(to.x, to.y);
            ctx.stroke();

            // Arrow head
            ctx.beginPath();
            ctx.moveTo(to.x, to.y);
            ctx.lineTo(to.x - headLength * Math.cos(angle - Math.PI / 6), to.y - headLength * Math.sin(angle - Math.PI / 6));
            ctx.lineTo(to.x - headLength * Math.cos(angle + Math.PI / 6), to.y - headLength * Math.sin(angle + Math.PI / 6));
            ctx.closePath();
            ctx.fill();
        }

        function drawLine(from, to, color, lineWidth = 3) {
            ctx.strokeStyle = color;
            ctx.lineWidth = lineWidth;
            ctx.lineCap = 'round';
            ctx.beginPath();
            ctx.moveTo(from.x, from.y);
            ctx.lineTo(to.x, to.y);
            ctx.stroke();
        }

        function drawFreehand(points, color, lineWidth = 3) {
            if (points.length < 2) return;
            ctx.strokeStyle = color;
            ctx.lineWidth = lineWidth;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            ctx.beginPath();
            ctx.moveTo(points[0].x, points[0].y);
            
            // Smooth the freehand line using quadratic curves
            for (let i = 1; i < points.length - 1; i++) {
                const xc = (points[i].x + points[i + 1].x) / 2;
                const yc = (points[i].y + points[i + 1].y) / 2;
                ctx.quadraticCurveTo(points[i].x, points[i].y, xc, yc);
            }
            
            if (points.length > 1) {
                ctx.lineTo(points[points.length - 1].x, points[points.length - 1].y);
            }
            ctx.stroke();
        }

        function drawDrawings() {
            const frame = frames[currentFrameIndex];
            frame.drawings.forEach(drawing => {
                const lineWidth = drawing.lineWidth || 3;
                switch (drawing.type) {
                    case 'arrow':
                        drawArrow(drawing.from, drawing.to, drawing.color, lineWidth);
                        break;
                    case 'line':
                        drawLine(drawing.from, drawing.to, drawing.color, lineWidth);
                        break;
                    case 'freehand':
                        drawFreehand(drawing.points, drawing.color, lineWidth);
                        break;
                }
            });
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawCourt();
            drawKorfAtPosition();
            
            const frame = frames[currentFrameIndex];
            frame.players.forEach(drawPlayer);
            drawBall();
            drawDrawings();

            // Draw temp drawing
            if (tempDrawing) {
                const lineWidth = currentLineWidth;
                switch (currentTool) {
                    case 'arrow':
                        drawArrow(tempDrawing.from, tempDrawing.to, currentColor, lineWidth);
                        break;
                    case 'line':
                        drawLine(tempDrawing.from, tempDrawing.to, currentColor, lineWidth);
                        break;
                    case 'freehand':
                        if (tempDrawing.points && tempDrawing.points.length > 0) {
                            drawFreehand(tempDrawing.points, currentColor, lineWidth);
                        }
                        break;
                }
            }
        }

        // Mouse/Touch helpers
        function getMousePos(evt) {
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            return {
                x: (evt.clientX - rect.left) * scaleX,
                y: (evt.clientY - rect.top) * scaleY
            };
        }

        function isPointInPlayer(pos, player) {
            const px = player.position[0] * scale;
            const py = player.position[1] * scale;
            const touchRadius = PLAYER_RADIUS * scale;
            
            if (player.gender === 'boy') {
                // Circle for male players
                const dist = Math.sqrt(Math.pow(pos.x - px, 2) + Math.pow(pos.y - py, 2));
                return dist <= touchRadius * 1.2;
            } else {
                // Square for female players
                return (pos.x >= px - touchRadius * 1.2 && pos.x <= px + touchRadius * 1.2 &&
                        pos.y >= py - touchRadius * 1.2 && pos.y <= py + touchRadius * 1.2);
            }
        }

        function isPointInBall(pos) {
            const frame = frames[currentFrameIndex];
            const bx = frame.ball.position[0] * scale;
            const by = frame.ball.position[1] * scale;
            const br = frame.ball.radius * scale;
            const dist = Math.sqrt(Math.pow(pos.x - bx, 2) + Math.pow(pos.y - by, 2));
            return dist <= br * 1.5;
        }

        // Helper function for line distance calculation
        function distanceToLine(point, lineStart, lineEnd) {
            const A = point.x - lineStart.x;
            const B = point.y - lineStart.y;
            const C = lineEnd.x - lineStart.x;
            const D = lineEnd.y - lineStart.y;

            const dot = A * C + B * D;
            const lenSq = C * C + D * D;
            let param = -1;
            if (lenSq !== 0) param = dot / lenSq;

            let xx, yy;

            if (param < 0) {
                xx = lineStart.x;
                yy = lineStart.y;
            } else if (param > 1) {
                xx = lineEnd.x;
                yy = lineEnd.y;
            } else {
                xx = lineStart.x + param * C;
                yy = lineStart.y + param * D;
            }

            const dx = point.x - xx;
            const dy = point.y - yy;
            return Math.sqrt(dx * dx + dy * dy);
        }

        // Frame management
        function updateFrameDisplay() {
            document.getElementById('currentFrameDisplay').textContent = currentFrameIndex + 1;
            document.getElementById('totalFramesDisplay').textContent = frames.length;
            updateFrameList();
        }

        function updateFrameList() {
            const frameList = document.getElementById('frameList');
            frameList.innerHTML = '';
            frames.forEach((frame, index) => {
                const btn = document.createElement('button');
                btn.className = 'frame-btn';
                btn.textContent = `${index + 1}`;
                if (index === currentFrameIndex) {
                    btn.classList.add('active');
                }
                btn.addEventListener('click', () => {
                    if (!isPlaying) {
                        currentFrameIndex = index;
                        draw();
                        updateFrameDisplay();
                    }
                });
                frameList.appendChild(btn);
            });
        }

        function addFrame() {
            if (isPlaying) return;
            frames.push(createNewFrame());
            currentFrameIndex = frames.length - 1;
            saveToHistory();
            draw();
            updateFrameDisplay();
        }

        function duplicateFrame() {
            if (isPlaying) return;
            const currentFrame = frames[currentFrameIndex];
            const newFrame = JSON.parse(JSON.stringify(currentFrame));
            frames.splice(currentFrameIndex + 1, 0, newFrame);
            currentFrameIndex++;
            saveToHistory();
            draw();
            updateFrameDisplay();
        }

        function deleteFrame() {
            if (isPlaying) return;
            if (frames.length <= 1) {
                alert('ÊúÄÂæå„ÅÆ„Éï„É¨„Éº„É†„ÅØÂâäÈô§„Åß„Åç„Åæ„Åõ„Çì„ÄÇ');
                return;
            }
            if (confirm('„Åì„ÅÆ„Éï„É¨„Éº„É†„ÇíÂâäÈô§„Åó„Åæ„Åô„ÅãÔºü')) {
                frames.splice(currentFrameIndex, 1);
                if (currentFrameIndex >= frames.length) {
                    currentFrameIndex = frames.length - 1;
                }
                saveToHistory();
                draw();
                updateFrameDisplay();
            }
        }

        // Playback controls
        function startPlayback() {
            if (isPlaying || frames.length <= 1) return;
            
            isPlaying = true;
            document.getElementById('playBtn').style.display = 'none';
            document.getElementById('stopBtn').style.display = 'flex';
            
            // Disable editing tools during playback
            document.querySelectorAll('[data-tool]').forEach(btn => btn.disabled = true);
            document.getElementById('addFrameBtn').disabled = true;
            document.getElementById('duplicateFrameBtn').disabled = true;
            document.getElementById('deleteFrameBtn').disabled = true;
            
            // Start from beginning if at the end
            if (currentFrameIndex >= frames.length - 1) {
                currentFrameIndex = 0;
            }
            
            playbackInterval = setInterval(() => {
                currentFrameIndex++;
                
                if (currentFrameIndex >= frames.length) {
                    if (loopPlayback) {
                        currentFrameIndex = 0;
                    } else {
                        stopPlayback();
                        return;
                    }
                }
                
                draw();
                updateFrameDisplay();
            }, playbackSpeed);
        }

        function stopPlayback() {
            isPlaying = false;
            document.getElementById('playBtn').style.display = 'flex';
            document.getElementById('stopBtn').style.display = 'none';
            
            if (playbackInterval) {
                clearInterval(playbackInterval);
                playbackInterval = null;
            }
            
            // Re-enable editing tools
            document.querySelectorAll('[data-tool]').forEach(btn => btn.disabled = false);
            document.getElementById('addFrameBtn').disabled = false;
            document.getElementById('duplicateFrameBtn').disabled = false;
            document.getElementById('deleteFrameBtn').disabled = false;
        }

        // Event handlers
        function handleDoubleClick(evt) {
            if (isPlaying) return;
            const pos = getMousePos(evt);
            const frame = frames[currentFrameIndex];

            // Check if clicked on a player
            for (const player of frame.players) {
                if (isPointInPlayer(pos, player)) {
                    const newNumber = prompt('„Éó„É¨„Ç§„É§„ÉºÁï™Âè∑„ÇíÂÖ•Âäõ„Åó„Å¶„Åè„Å†„Åï„ÅÑ:', player.number);
                    if (newNumber !== null && newNumber.trim() !== '') {
                        player.number = newNumber.trim();
                        saveToHistory();
                        draw();
                    }
                    return;
                }
            }
        }

        function handleMouseDown(evt) {
            if (isPlaying) return;
            const pos = getMousePos(evt);
            const frame = frames[currentFrameIndex];

            if (currentTool === 'select') {
                // Check ball first
                if (isPointInBall(pos)) {
                    selectedObject = frame.ball;
                    isDragging = true;
                    offset.x = pos.x - frame.ball.position[0] * scale;
                    offset.y = pos.y - frame.ball.position[1] * scale;
                    return;
                }

                // Check players
                for (const player of frame.players) {
                    if (isPointInPlayer(pos, player)) {
                        selectedObject = player;
                        isDragging = true;
                        offset.x = pos.x - player.position[0] * scale;
                        offset.y = pos.y - player.position[1] * scale;
                        return;
                    }
                }
            } else if (currentTool === 'eraser') {
                // Eraser mode - remove drawings at click position
                const eraserRadius = 15;
                frame.drawings = frame.drawings.filter(drawing => {
                    if (drawing.type === 'freehand') {
                        // Check if any point is near the eraser
                        return !drawing.points.some(p => 
                            Math.sqrt(Math.pow(p.x - pos.x, 2) + Math.pow(p.y - pos.y, 2)) < eraserRadius
                        );
                    } else if (drawing.type === 'arrow' || drawing.type === 'line') {
                        // Check if line passes near the eraser
                        const dist = distanceToLine(pos, drawing.from, drawing.to);
                        return dist > eraserRadius;
                    }
                    return true;
                });
                saveToHistory();
                draw();
            } else if (['arrow', 'line'].includes(currentTool)) {
                drawingStart = pos;
                tempDrawing = { from: pos, to: pos };
            } else if (currentTool === 'freehand') {
                drawingStart = pos;
                tempDrawing = { points: [pos] };
            }
        }

        function handleMouseMove(evt) {
            if (isPlaying) return;
            const pos = getMousePos(evt);
            const frame = frames[currentFrameIndex];

            if (currentTool === 'select' && isDragging && selectedObject) {
                selectedObject.position[0] = (pos.x - offset.x) / scale;
                selectedObject.position[1] = (pos.y - offset.y) / scale;
                draw();
            } else if (currentTool === 'eraser' && evt.buttons === 1) {
                // Continuous erasing while mouse is down
                const eraserRadius = 15;
                const beforeLength = frame.drawings.length;
                frame.drawings = frame.drawings.filter(drawing => {
                    if (drawing.type === 'freehand') {
                        return !drawing.points.some(p => 
                            Math.sqrt(Math.pow(p.x - pos.x, 2) + Math.pow(p.y - pos.y, 2)) < eraserRadius
                        );
                    } else if (drawing.type === 'arrow' || drawing.type === 'line') {
                        const dist = distanceToLine(pos, drawing.from, drawing.to);
                        return dist > eraserRadius;
                    }
                    return true;
                });
                if (beforeLength !== frame.drawings.length) {
                    draw();
                }
            } else if (tempDrawing) {
                if (['arrow', 'line'].includes(currentTool)) {
                    tempDrawing.to = pos;
                } else if (currentTool === 'freehand') {
                    // Add point with some distance threshold to avoid too many points
                    const lastPoint = tempDrawing.points[tempDrawing.points.length - 1];
                    const dist = Math.sqrt(
                        Math.pow(pos.x - lastPoint.x, 2) + 
                        Math.pow(pos.y - lastPoint.y, 2)
                    );
                    if (dist > 2) { // Only add if moved more than 2 pixels
                        tempDrawing.points.push(pos);
                    }
                }
                draw();
            }
        }

        function handleMouseUp(evt) {
            if (isPlaying) return;
            const frame = frames[currentFrameIndex];

            if (currentTool === 'select') {
                if (isDragging) {
                    saveToHistory();
                }
                isDragging = false;
                selectedObject = null;
            } else if (currentTool === 'eraser') {
                // Save history after erasing
                if (evt.type === 'mouseup') {
                    saveToHistory();
                }
            } else if (tempDrawing && drawingStart) {
                const pos = getMousePos(evt);
                
                if (currentTool === 'arrow') {
                    frame.drawings.push({
                        type: 'arrow',
                        from: drawingStart,
                        to: pos,
                        color: currentColor,
                        lineWidth: currentLineWidth
                    });
                } else if (currentTool === 'line') {
                    frame.drawings.push({
                        type: 'line',
                        from: drawingStart,
                        to: pos,
                        color: currentColor,
                        lineWidth: currentLineWidth
                    });
                } else if (currentTool === 'freehand') {
                    if (tempDrawing.points.length > 1) {
                        frame.drawings.push({
                            type: 'freehand',
                            points: tempDrawing.points,
                            color: currentColor,
                            lineWidth: currentLineWidth
                        });
                    }
                }

                saveToHistory();
                tempDrawing = null;
                drawingStart = null;
                draw();
            }
        }

        // Tool selection
        document.querySelectorAll('[data-tool]').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('[data-tool]').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                currentTool = btn.dataset.tool;
                
                // Update cursor based on tool
                if (currentTool === 'select') {
                    canvas.style.cursor = 'default';
                } else if (currentTool === 'eraser') {
                    canvas.style.cursor = 'not-allowed';
                } else {
                    canvas.style.cursor = 'crosshair';
                }
            });
        });

        // Line width control
        const lineWidthSlider = document.getElementById('lineWidth');
        const lineWidthValue = document.getElementById('lineWidthValue');
        if (lineWidthSlider && lineWidthValue) {
            lineWidthSlider.addEventListener('input', (e) => {
                currentLineWidth = parseInt(e.target.value);
                lineWidthValue.textContent = currentLineWidth;
            });
        }

        // Color selection
        document.querySelectorAll('.color-option').forEach(opt => {
            opt.addEventListener('click', () => {
                document.querySelectorAll('.color-option').forEach(o => o.classList.remove('active'));
                opt.classList.add('active');
                currentColor = opt.dataset.color;
            });
        });

        // History management
        function saveToHistory() {
            const state = JSON.parse(JSON.stringify(frames));
            history = history.slice(0, historyIndex + 1);
            history.push(state);
            historyIndex++;
            if (history.length > 50) {
                history.shift();
                historyIndex--;
            }
        }

        const undoBtn = document.getElementById('undoBtn');
        if (undoBtn) {
            undoBtn.addEventListener('click', () => {
                if (historyIndex > 0 && !isPlaying) {
                    historyIndex--;
                    frames = JSON.parse(JSON.stringify(history[historyIndex]));
                    draw();
                    updateFrameDisplay();
                }
            });
        }

        const redoBtn = document.getElementById('redoBtn');
        if (redoBtn) {
            redoBtn.addEventListener('click', () => {
                if (historyIndex < history.length - 1 && !isPlaying) {
                    historyIndex++;
                    frames = JSON.parse(JSON.stringify(history[historyIndex]));
                    draw();
                    updateFrameDisplay();
                }
            });
        }

        // Clear and reset
        const clearDrawingBtn = document.getElementById('clearDrawingBtn');
        if (clearDrawingBtn) {
            clearDrawingBtn.addEventListener('click', () => {
                if (isPlaying) return;
                if (confirm('ÁèæÂú®„ÅÆ„Éï„É¨„Éº„É†„ÅÆÊèèÁîª„ÇíÂÖ®„Å¶ÂâäÈô§„Åó„Åæ„Åô„ÅãÔºü')) {
                    frames[currentFrameIndex].drawings = [];
                    saveToHistory();
                    draw();
                }
            });
        }

        const resetBtn = document.getElementById('resetBtn');
        if (resetBtn) {
            resetBtn.addEventListener('click', () => {
                if (isPlaying) return;
                if (confirm('ÂÖ®„Å¶„Çí„É™„Çª„ÉÉ„Éà„Åó„Åæ„Åô„ÅãÔºü„Åì„ÅÆÊìç‰Ωú„ÅØÂèñ„ÇäÊ∂à„Åõ„Åæ„Åõ„Çì„ÄÇ')) {
                    stopPlayback();
                    frames = [createNewFrame()];
                    currentFrameIndex = 0;
                    history = [];
                    historyIndex = -1;
                    draw();
                    updateFrameDisplay();
                }
            });
        }

        // Frame control buttons
        document.getElementById('addFrameBtn').addEventListener('click', addFrame);
        document.getElementById('duplicateFrameBtn').addEventListener('click', duplicateFrame);
        document.getElementById('deleteFrameBtn').addEventListener('click', deleteFrame);

        // Playback control buttons
        document.getElementById('playBtn').addEventListener('click', startPlayback);
        document.getElementById('stopBtn').addEventListener('click', stopPlayback);

        // Loop checkbox
        document.getElementById('loopCheckbox').addEventListener('change', (e) => {
            loopPlayback = e.target.checked;
        });

        // Playback speed control
        const playbackSpeedSlider = document.getElementById('playbackSpeed');
        const speedValue = document.getElementById('speedValue');
        if (playbackSpeedSlider && speedValue) {
            playbackSpeedSlider.addEventListener('input', (e) => {
                playbackSpeed = parseInt(e.target.value);
                const speed = (1000 / playbackSpeed).toFixed(1);
                speedValue.textContent = `${speed}x`;
                
                // Restart playback with new speed if currently playing
                if (isPlaying) {
                    clearInterval(playbackInterval);
                    playbackInterval = setInterval(() => {
                        currentFrameIndex++;
                        
                        if (currentFrameIndex >= frames.length) {
                            if (loopPlayback) {
                                currentFrameIndex = 0;
                            } else {
                                stopPlayback();
                                return;
                            }
                        }
                        
                        draw();
                        updateFrameDisplay();
                    }, playbackSpeed);
                }
            });
        }

        // Save/Load
        const saveBtn = document.getElementById('saveBtn');
        if (saveBtn) {
            saveBtn.addEventListener('click', () => {
                const data = JSON.stringify(frames, null, 2);
                const saveDataEl = document.getElementById('saveData');
                const saveModalEl = document.getElementById('saveModal');
                if (saveDataEl) saveDataEl.value = data;
                if (saveModalEl) saveModalEl.classList.add('active');
            });
        }

        const closeSaveModal = document.getElementById('closeSaveModal');
        if (closeSaveModal) {
            closeSaveModal.addEventListener('click', () => {
                const saveModalEl = document.getElementById('saveModal');
                if (saveModalEl) saveModalEl.classList.remove('active');
            });
        }

        const copyDataBtn = document.getElementById('copyDataBtn');
        if (copyDataBtn) {
            copyDataBtn.addEventListener('click', () => {
                const textarea = document.getElementById('saveData');
                if (textarea) {
                    textarea.select();
                    document.execCommand('copy');
                    alert('„ÇØ„É™„ÉÉ„Éó„Éú„Éº„Éâ„Å´„Ç≥„Éî„Éº„Åó„Åæ„Åó„ÅüÔºÅ');
                }
            });
        }

        const loadBtn = document.getElementById('loadBtn');
        if (loadBtn) {
            loadBtn.addEventListener('click', () => {
                const loadModalEl = document.getElementById('loadModal');
                if (loadModalEl) loadModalEl.classList.add('active');
            });
        }

        const closeLoadModal = document.getElementById('closeLoadModal');
        if (closeLoadModal) {
            closeLoadModal.addEventListener('click', () => {
                const loadModalEl = document.getElementById('loadModal');
                if (loadModalEl) loadModalEl.classList.remove('active');
            });
        }

        const loadDataBtn = document.getElementById('loadDataBtn');
        if (loadDataBtn) {
            loadDataBtn.addEventListener('click', () => {
                try {
                    const loadDataEl = document.getElementById('loadData');
                    if (!loadDataEl) return;
                    
                    const data = loadDataEl.value;
                    const loadedFrames = JSON.parse(data);
                    stopPlayback();
                    frames = loadedFrames;
                    currentFrameIndex = 0;
                    history = [];
                    historyIndex = -1;
                    draw();
                    updateFrameDisplay();
                    
                    const loadModalEl = document.getElementById('loadModal');
                    if (loadModalEl) loadModalEl.classList.remove('active');
                    loadDataEl.value = '';
                    alert('„Éó„É¨„Ç§„ÇíË™≠„ÅøËæº„Åø„Åæ„Åó„ÅüÔºÅ');
                } catch (e) {
                    alert('„Éá„Éº„Çø„ÅÆË™≠„ÅøËæº„Åø„Å´Â§±Êïó„Åó„Åæ„Åó„Åü„ÄÇÊ≠£„Åó„ÅÑJSONÂΩ¢Âºè„ÅãÁ¢∫Ë™ç„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ');
                }
            });
        }

        // Export
        const exportBtn = document.getElementById('exportBtn');
        if (exportBtn) {
            exportBtn.addEventListener('click', () => {
                const link = document.createElement('a');
                link.download = `indoor-korfball-play-frame${currentFrameIndex + 1}-${Date.now()}.png`;
                link.href = canvas.toDataURL();
                link.click();
            });
        }

        // Event listeners
        canvas.addEventListener('dblclick', handleDoubleClick);
        canvas.addEventListener('mousedown', handleMouseDown);
        canvas.addEventListener('mousemove', handleMouseMove);
        canvas.addEventListener('mouseup', handleMouseUp);
        canvas.addEventListener('mouseleave', handleMouseUp);

        // Touch events
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            const touch = e.touches[0];
            const mouseEvent = new MouseEvent('mousedown', {
                clientX: touch.clientX,
                clientY: touch.clientY
            });
            handleMouseDown(mouseEvent);
        });

        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            const touch = e.touches[0];
            const mouseEvent = new MouseEvent('mousemove', {
                clientX: touch.clientX,
                clientY: touch.clientY
            });
            handleMouseMove(mouseEvent);
        });

        canvas.addEventListener('touchend', (e) => {
            e.preventDefault();
            handleMouseUp(e);
        });

        // Initialize
        window.addEventListener('resize', resizeCanvas);
        canvas.style.cursor = 'default'; // Set initial cursor for select tool
        resizeCanvas();
        saveToHistory();
        updateFrameDisplay();
    </script>
</body>
</html>
